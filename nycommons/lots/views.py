from collections import OrderedDict
import geojson
import json
from operator import itemgetter
from pint import UnitRegistry
from random import shuffle
import re

from django.contrib.contenttypes.models import ContentType
from django.contrib import messages
from django.db.models import Count, Sum
from django.http import HttpResponseRedirect, Http404
from django.utils.text import slugify
from django.utils.translation import ugettext_lazy as _
from django.views.generic import DetailView, View

from caching.base import cached
from braces.views import JSONResponseMixin

from groundtruth.forms import GroundtruthRecordForm
from inplace.views import GeoJSONListView, PlacesDetailView
from livinglots_genericviews.views import JSONResponseView
from livinglots_lots.signals import lot_details_loaded
from livinglots_lots.views import (BaseCreateLotView, FilteredLotsMixin,
                                   LotsCountView)
from livinglots_lots.views import LotDetailView as BaseLotDetailView
from livinglots_lots.views import LotsCSV as BaseLotsCSV
from livinglots_lots.views import LotsKML as BaseLotsKML
from livinglots_lots.views import LotsGeoJSON as BaseLotsGeoJSON
from nycdata.parcels.models import Parcel
from organize.models import Organizer
from .models import Lot


ureg = UnitRegistry()


class LotDetailView(PlacesDetailView):
    model = Lot
    slug_field = 'bbl'
    slug_url_kwarg = 'bbl'

    def check_lot_sanity(self, request, lot):
        """
        Sanity check the lot. In particular, check for missing things every lot
        should have. Warn superusers if there is something amiss.
        """
        if not lot.centroid:
            messages.warning(request, ("This lot doesn't have a center point "
                                       "(centroid). You should edit the lot "
                                       "and add one."))
        if not lot.polygon:
            messages.warning(request, ("This lot doesn't have a shape "
                                       "(polygon). You should edit the lot "
                                       "and add one."))

    def get_object(self):
        lot = super(LotDetailView, self).get_object()
        if not (lot.is_visible or self.request.user.has_perm('lots.view_all_lots')):
            # Make an exception for lots with low known_use_certainty values,
            # which are being used in stealth mode right now
            if lot.known_use_certainty > 3:
                raise Http404
        return lot

    def get_groundtruth_form(self, request):
        kwargs = {
            'initial': {
                'content_type': ContentType.objects.get_for_model(self.object),
                'object_id': self.object.pk,
            },
            'user': request.user,
        }
        return GroundtruthRecordForm(**kwargs)

    def get_context_data(self, **kwargs):
        context = super(LotDetailView, self).get_context_data(**kwargs)
        context.update({
            'groundtruth_form': self.get_groundtruth_form(self.request),
        })
        return context

    def get(self, request, *args, **kwargs):
        self.object = self.get_object()
        if request.user.is_superuser:
            self.check_lot_sanity(request, self.object)

        # Redirect to the lot's group, if it has one
        lot_details_loaded.send(sender=self, instance=self.object)
        if self.object.group:
            messages.info(request, _("The lot you requested is part of a "
                                     "group. Here is the group's page."))
            return HttpResponseRedirect(self.object.group.get_absolute_url())
        return super(LotDetailView, self).get(request, *args, **kwargs)


class LotDetailViewJSON(JSONResponseMixin, BaseLotDetailView):
    slug_field = 'pk'
    slug_url_kwarg = 'pk'

    def round_acres(self, lot):
        try:
            # Attempt to round to smallest number of digits we can
            decimal_places = 1
            rounded = 0
            area_acres = lot.area_acres
            if not area_acres:
                return None
            while not rounded:
                rounded = round(area_acres, decimal_places)
                decimal_places += 1
            return rounded
        except TypeError:
            return None

    def get(self, request, *args, **kwargs):
        lot = self.object = self.get_object()

        context = {
            'area_acres': self.round_acres(lot),
            'bbl': lot.bbl,
            'centroid': {
                'x': lot.centroid.x,
                'y': lot.centroid.y,
            },
            'commons_type': lot.commons_type,
            'commons_type_slug': slugify(lot.commons_type),
            'organizing': lot.organizing,
            'name': lot.display_name,
            'number_of_lots': lot.number_of_lots,
            'part_of_group': lot.group is not None,
            'priority': lot.priority,
            'url': lot.get_absolute_url(),
        }
        if lot.owner:
            context['owner'] = lot.owner.name

        return self.render_json_response(context)


class LotGeoJSONMixin(object):

    def get_acres(self, lot):
        acres = getattr(lot, 'area_acres', None)
        if not acres:
            return 'unknown'
        return round(acres, 2)

    def get_layer(self, lot):
        if lot.known_use:
            return 'in_use'
        elif lot.owner and lot.owner.owner_type == 'public':
            return 'public'
        elif lot.owner and lot.owner.owner_type == 'private':
            return 'private'
        return ''

    def get_properties(self, lot):
        return {
            'address_line1': lot.address_line1,
            'has_organizers': lot.organizers__count > 0,
            'layer': self.get_layer(lot),
            'number_of_lots': lot.number_of_lots,
            'number_of_lots_plural': lot.number_of_lots > 1,
            'owner': str(lot.owner) or 'unknown',
            'pk': lot.pk,
            'size': self.get_acres(lot),
        }

    def get_geometry(self, lot):
        try:
            lot_geojson = lot.geojson
        except Exception:
            if lot.polygon:
                lot_geojson = lot.polygon.geojson
            else:
                lot_geojson = lot.centroid.geojson
        return json.loads(lot_geojson)

    def get_feature(self, lot):
        return geojson.Feature(
            lot.pk,
            geometry=self.get_geometry(lot),
            properties=self.get_properties(lot),
        )


class LotsGeoJSONCentroid(LotGeoJSONMixin, FilteredLotsMixin, GeoJSONListView):

    def get_queryset(self):
        return self.get_lots().qs.filter(centroid__isnull=False).geojson(
            field_name='centroid',
            precision=8,
        ).select_related(
            'known_use',
            'lotgroup',
            'owner__owner_type'
        ).annotate(organizers__count=Count('organizers'))

    def get_features(self):
        filterset = self.get_lots()
        key = '%s:%s' % (self.__class__.__name__, filterset.hashkey())

        def _get_value():
            features = super(LotsGeoJSONCentroid, self).get_features()
            shuffle(features)
            return features
        return cached(_get_value, key, 60 * 15)


class LotsGeoJSONPolygon(LotGeoJSONMixin, FilteredLotsMixin, GeoJSONListView):

    def get_properties(self, lot):
        properties = super(LotsGeoJSONPolygon, self).get_properties(lot)
        properties['centroid'] = (
            round(lot.centroid.x, 4),
            round(lot.centroid.y, 4)
        )
        return properties

    def get_queryset(self):
        return self.get_lots().qs.filter(polygon__isnull=False).geojson(
            field_name='polygon',
            precision=8,
        ).select_related(
            'known_use',
            'lotgroup',
            'owner__owner_type'
        ).annotate(organizers__count=Count('organizers'))

    def get_features(self):
        filterset = self.get_lots()
        key = '%s:%s' % (self.__class__.__name__, filterset.hashkey())

        def _get_value():
            return super(LotsGeoJSONPolygon, self).get_features()
        return cached(_get_value, key, 60 * 15)


class LotsOwnershipOverview(FilteredLotsMixin, JSONResponseView):

    layer_labels = {
        'organizing': 'organizing',
        'organizing_priority': 'organizing & development pending',
        'community_project': 'community project',
        'priority': 'development pending',
        'vacant_lot': 'vacant lot / garden',
        'park': 'park',
        'park_building': 'underutilized park building',
        'library': 'library',
        'public_housing': 'public housing site',
        'post_office': 'post office',
        'waterfront': 'waterfront',
    }

    def count_organizers(self, lots_qs):
        return Organizer.objects.filter(
            content_type=ContentType.objects.get_for_model(Lot),
            object_id__in=lots_qs.values_list('pk', flat=True)
        ).count()

    def get_organizers(self, lots_qs):
        organizers = []
        organizers_qs = Organizer.objects.filter(
            content_type=ContentType.objects.get_for_model(Lot),
            object_id__in=lots_qs.values_list('pk', flat=True)
        )
        for organizer in organizers_qs:
            organizers.append({
                'name': organizer.name,
            })
        return organizers

    def get_owners(self, lots_qs):
        owners = []
        for row in lots_qs.values('owner__name').annotate(count=Count('pk'), area=Sum('polygon_area')).order_by():
            try:
                area = float(row['area'])
            except TypeError:
                area = None
            owners.append({
                'name': row['owner__name'],
                'area': area,
                'count': row['count'],
            })
        return sorted(owners, key=itemgetter('name'))

    def get_layers(self, lots):
        return OrderedDict([
            ('organizing', lots.filter(organizing=True)),
            ('organizing_priority', lots.filter(organizing=True, priority=True)),
            ('community_project', lots.filter(steward_projects__isnull=False)),
            ('priority', lots.filter(priority=True)),
            ('vacant_lot', lots.filter(commons_type='vacant lot / garden')),
            ('park', lots.filter(commons_type='park')),
            ('park_building', lots.filter(commons_type='park building')),
            ('library', lots.filter(commons_type='library')),
            ('public_housing', lots.filter(commons_type='public housing')),
            ('post_office', lots.filter(commons_type='post office')),
            ('waterfront', lots.filter(commons_type='waterfront')),
        ])

    def get_layer_counts(self, layers):
        counts = []
        for layer, qs in layers.items():
            organizers = self.get_organizers(qs)
            owners = self.get_owners(qs)
            if organizers or owners:
                counts.append({
                    'count': sum([o['count'] for o in owners]),
                    'label': self.layer_labels[layer],
                    'organizers_count': self.count_organizers(qs),
                    'organizers': organizers,
                    'owners': owners,
                    'priority': layer in ('community_project', 'priority',),
                    'type': layer,
                })
        return counts

    def get_context_data(self, **kwargs):
        lots = self.get_lots().qs
        layers = self.get_layers(lots)
        return self.get_layer_counts(layers)


class LotsCountViewWithAcres(LotsCountView):

    def get_area_in_acres(self, lots_qs):
        sqft = lots_qs.aggregate(total_area=Sum('polygon_area'))['total_area']
        if not sqft:
            return 0
        sqft = sqft * (ureg.feet ** 2)
        acres = sqft.to(ureg.acre).magnitude
        return int(round(acres))

    def get_context_data(self, **kwargs):
        lots = self.get_lots().qs
        no_known_use = lots.filter(known_use__isnull=True)
        in_use = lots.filter(known_use__isnull=False, known_use__visible=True)

        context = {
            'lots-count': lots.count(),
            'lots-acres': self.get_area_in_acres(lots),
            'no-known-use-count': no_known_use.count(),
            'no-known-use-acres': self.get_area_in_acres(no_known_use),
            'in-use-count': in_use.count(),
            'in-use-acres': self.get_area_in_acres(in_use),
        }
        return context


class LotExportMixin(object):
    fields = ('address_line1', 'name', 'city', 'state_province', 'postal_code',
              'bbl', 'latitude', 'longitude', 'commons_type', 'known_use',
              'owner', 'owner_type', 'priority',
              'development_pending_explanation_plaintext', 'organizing')

    def get_sitename(self):
        return 'NYCommons'


class LotsCSV(LotExportMixin, BaseLotsCSV):

    def get_header_name(self, field):
        if field == 'priority':
            return 'development pending'
        if field == 'organizing':
            return 'has organizers'
        if field == 'development_pending_explanation_plaintext':
            return 'development pending explanation'
        return super(LotsCSV, self).get_header_name(field)


class LotsKML(LotExportMixin, BaseLotsKML):
    pass


class LotsGeoJSON(LotExportMixin, BaseLotsGeoJSON):

    def get_queryset(self):
        return self.get_lots().qs


class SearchView(JSONResponseMixin, View):
    # BBL is ten digits
    bbl_pattern = re.compile(r'.*(\d{10}).*')

    # Look for something of the form <borough> <block> <lot>, no matter what is
    # separating each
    borough_block_lot_pattern = re.compile(r'.*?(\w+)\D+(\d+)\D+(\d+).*?')

    def get_search_results(self, q, max=5):
        return (self.get_lot_results(q, max=max) +
                self.get_parcel_results(q, max=max))[:max]

    def get_lot_results(self, q, max=5):
        def _lot_result_dict(lot):
            return {
                'longitude': lot.centroid.x,
                'latitude': lot.centroid.y,
                'name': lot.name,
            }
        return [_lot_result_dict(l) for l in Lot.objects.filter(name__icontains=q)[:max]]

    def get_parcel_results(self, q, max=5):
        def _parcel_result_dict(parcel):
            return {
                'longitude': parcel.geom.centroid.x,
                'latitude': parcel.geom.centroid.y,
                'name': parcel.bbl,
            }

        # Try to get a bbl we can search by
        try:
            bbl = self.bbl_pattern.match(q).group(1)
        except Exception:
            try:
                # Try to find borough, block, and lot, convert to bbl
                bbl = build_bbl(*self.borough_block_lot_pattern.match(q).groups())
            except Exception:
                bbl = None

        if bbl:
            return [_parcel_result_dict(p) for p in Parcel.objects.filter(bbl=bbl)[:max]]
        return []

    def get(self, request, *args, **kwargs):
        return self.render_json_response({
            'results': self.get_search_results(request.GET.get('q', None)),
        })


class SameOwner(DetailView):
    model = Lot
    template_name = 'livinglots/lots/same_owner.html'

    def get_context_data(self, **kwargs):
        lot = self.get_object()
        organizing = (self.request.GET.get('organizing', False) == 'true')
        priority = (self.request.GET.get('priority', False) == 'true')

        lots = lot.owner.lot_set.filter(group=None).exclude(pk=lot.pk)
        if organizing:
            lots = lots.filter(organizing=True)
        if priority:
            lots = lots.filter(priority=True)
        context = super(SameOwner, self).get_context_data(**kwargs)
        context['lots'] = sorted(lots, key=lambda l: l.display_name)
        context['lot'] = lot
        context['organizing'] = organizing
        context['priority'] = priority
        return context


class CreateLotView(BaseCreateLotView):

    def get_parcels(self, pks):
        return Parcel.objects.filter(pk__in=pks)
